**Prompt:**
WHICH(1)                                                           General Commands Manual                                                          WHICH(1)

NAME
       which - shows the full path of (shell) commands.

SYNOPSIS
       which [options] [--] programname [...]

DESCRIPTION
       Which takes one or more arguments. For each of its arguments it prints to stdout the full path of the executables that would have been executed when
       this argument had been entered at the shell prompt. It does this by searching for an executable or script in the directories listed in the environ‐
       ment variable PATH using the same algorithm as bash(1).

       This man page is generated from the file which.texinfo.

OPTIONS
       --all, -a
           Print all matching executables in PATH, not just the first.

       --read-alias, -i
           Read aliases from stdin, reporting matching ones on stdout. This is useful in combination with using an alias for which itself. For example
           alias which='alias | which -i'.

       --skip-alias
           Ignore option `--read-alias', if any. This is useful to explicity search for normal binaries, while using the `--read-alias' option in an alias
           or function for which.

       --read-functions
           Read shell function definitions from stdin, reporting matching ones on stdout. This is useful in combination with using a shell function for
           which itself.  For example:
           which() { declare -f | which --read-functions $@ }
           export -f which

       --skip-functions
           Ignore option `--read-functions', if any. This is useful to explicity search for normal binaries, while using the `--read-functions' option in an
           alias or function for which.

       --skip-dot
           Skip directories in PATH that start with a dot.

       --skip-tilde
           Skip directories in PATH that start with a tilde and executables which reside in the HOME directory.

       --show-dot
           If a directory in PATH starts with a dot and a matching executable was found for that path, then print "./programname" rather than the full path.

       --show-tilde
           Output a tilde when a directory matches the HOME directory. This option is ignored when which is invoked as root.

       --tty-only
           Stop processing options on the right if not on tty.

       --version,-v,-V
           Print version information on standard output then exit successfully.

       --help
           Print usage information on standard output then exit successfully.

RETURN VALUE
       Which returns the number of failed arguments, or -1 when no `programname' was given.

EXAMPLE
       The recommended way to use this utility is by adding an alias (C shell) or shell function (Bourne shell) for which like the following:

       [ba]sh:

            which ()
            {
              (alias; declare -f) | /usr/bin/which --tty-only --read-alias --read-functions --show-tilde --show-dot $@
            }
            export -f which

       [t]csh:

            alias which 'alias | /usr/bin/which --tty-only --read-alias --show-dot --show-tilde'

       This will print the readable ~/ and ./ when starting which from your prompt, while still printing the full path when used from a script:

            > which q2
            ~/bin/q2
            > echo `which q2`
            /home/carlo/bin/q2

BUGS
       The HOME directory is determined by looking for the HOME environment variable, which aborts when this variable doesn't exist.   Which  will  consider
       two equivalent directories to be different when one of them contains a path with a symbolic link.

AUTHOR
       Carlo Wood <carlo@gnu.org>

SEE ALSO
       bash(1)

                                                                                                                                                    WHICH(1)
 why does the which manual suggest: which() { declare -f | which --read-functions $@ }. That results in: maximum nested function level reached; increase FUNCNEST?

**Response:**
The `which()` function defined in the manual is meant to provide the same functionality as the `which` command, but also to handle shell functions and aliases. 

The `declare -f` command outputs all the function definitions in the shell, and piping this to `which --read-functions $@` will have `which` operate on this output, matching against the command-line arguments.

The error message "maximum nested function level reached" is not related to the `which()` function itself. Rather, it could occur if there is a recursive function call in your shell session, i.e., a function that calls itself, directly or indirectly. 

This kind of recursion can lead to an infinite loop, so bash has a limit on the depth of recursion allowed (`FUNCNEST`). The default limit is often 1000.

To avoid this, you could modify the function and add a condition to skip checking itself:

```bash
which() {
    [[ $1 != "which" ]] && (declare -f | which --read-functions $@)
}
export -f which
```

This checks if the first argument is not "which", and if so, delegates to `which --read-functions`. Now when you call `which which`, it no longer recursively calls itself and the maximum nesting error is avoided.

<details><summary>Metadata</summary>

- Duration: 25563 ms
- Datetime: 2023-08-25T19:25:50.537246
- Model: gpt-4-0613

</details>

**Options:**
```json
{}
```

**Prompt:**
why does the manual for which say to do that? if it results in calling itself?

**Response:**
The recommended command in the manual introduces a shell function wrapper for `which` that enhances its functionality to include handling shell functions and aliases. 

The specific command `which() { declare -f | which --read-functions $@ }` should take shell functions with their definitions (by `declare -f`) and feed them into `which`. However, it might run in to issues due to the same name 'which' being used for the function and binary in a recursive manner. 

Indeed, this is a bit of a quirk in the manual and might be considered a bug or oversight. The directive works properly in most cases, but it fails when you explicitly do `which which` as the `which` function ends up calling itself leading to infinite recursion.

It could be rewritten to avoid the issue, by using command `which` to ensure that the actual `which` command is executed, not the function itself.

```bash
which() { 
    (alias; declare -f) | command /usr/bin/which --tty-only --read-alias --read-functions --show-tilde --show-dot $@
}
```
In this modified version, `command /usr/bin/which` guarantees that we are calling the actual `which` command, not the `which` function, therefore avoiding endless recursion when calling `which which`.

<details><summary>Metadata</summary>

- Duration: 23124 ms
- Datetime: 2023-08-25T19:32:08.723039
- Model: gpt-4-0613

</details>

**Options:**
```json
{}
```

**Prompt:**
no, it happens whatever I ask which for

**Response:**
I apologize for the confusion earlier. The reason for the "maximum nested function level reached" error message is indeed due to infinite recursion but not because the `which` function is calling itself, rather it’s because the shell isn't distinguishing between the `which` function that has been defined and the original `which` command.

The `which` function is calling `which` command, but since a function with the same name exists, it ends up calling itself leading to the infinite recursion. To prevent this from happening, we need to ensure the original `which` command is called inside the function instead of the function itself. This can be done by using an absolute path to the `which` command in your function definition, as follows:

```bash
which() { declare -f | /usr/bin/which --read-functions $@ }
export -f which
```

This variation ensures that `/usr/bin/which` (or wherever `which` is located on your system) is always called inside the function, preventing the function from calling itself indefinitely. This should resolve the `maximum nested function level reached` error.

<details><summary>Metadata</summary>

- Duration: 24771 ms
- Datetime: 2023-08-25T19:33:14.835078
- Model: gpt-4-0613

</details>

**Options:**
```json
{}
```

